// ===== CoLabEndpoint — supports new object-style ?filters={} format (NO limit/pageLimit) =====
let
  BaseUrl          = "https://app.colabsoftware.com",
  ClientIdParam    = Text.From(ClientId),
  ApiKeyParam      = Text.From(ApiKey),
  FiltersParam     = try Text.From(Filters) otherwise "",

  // Pre-compute filter text ONCE (avoids re-parsing JSON on every page request)
  FiltersText =
    if FiltersParam <> "" then
      let
        parsed = try Json.Document(FiltersParam) otherwise null
      in
        if parsed <> null and Value.Is(parsed, type record)
        then Text.FromBinary(Json.FromValue(parsed))
        else FiltersParam
    else
      null,

  Headers = [
    Authorization  = ApiKeyParam,
    #"X-Client-Id" = ClientIdParam,
    Accept         = "application/json"
  ],

  // Reusable fetch (retries ONLY transient statuses)
  FetchWithRetry =
    (relativePath as text, queryRec as record, optional attempt as nullable number) as any =>
    let
      A = if attempt = null then 1 else attempt,
      DelaySecs = Number.Power(2, A - 1),

      TryResp =
        let
          raw =
            Web.Contents(
              BaseUrl,
              [
                RelativePath = relativePath,
                Query = queryRec,
                Headers = Headers,
                ManualStatusHandling = {400,401,403,404,409,422,429,500,502,503}
              ]
            ),
          status   = try Record.Field(Value.Metadata(raw), "Response.Status") otherwise null,
          bodyText = try Text.FromBinary(raw) otherwise null
        in
          [Raw = raw, Status = status, Body = bodyText],

      bodySafe    = if TryResp[Body] = null then "" else TryResp[Body],
      isTransient = (TryResp[Status] <> null) and List.Contains({429,500,502,503}, TryResp[Status]),

      Result =
        if (TryResp[Status] <> null) and (TryResp[Status] >= 400) then
          if isTransient and (A < 5) then
            Function.InvokeAfter(
              () => @FetchWithRetry(relativePath, queryRec, A + 1),
              #duration(0, 0, DelaySecs, 0)
            )
          else
            error ("HTTP " & Number.ToText(TryResp[Status]) & " from " & relativePath
                   & " (attempt " & Number.ToText(A) & " of 4) | "
                   & Text.Start(bodySafe, 500))
        else
          let
            parsed = try Json.Document(TryResp[Raw])
          in
            if parsed[HasError] then
              error ("Invalid JSON from " & relativePath & " | " & Text.Start(bodySafe, 500))
            else
              parsed[Value]
    in
      Result,

  ExtractList = (json as any) as list =>
    if json = null then {}
    else if Value.Is(json, type list) then json
    else if Value.Is(json, type record) and Record.HasFields(json, "data") then
      let d = json[data] in if Value.Is(d, type list) then d else if d = null then {} else {d}
    else if Value.Is(json, type record) and Record.HasFields(json, "records") then json[records]
    else if Value.Is(json, type record) and Record.HasFields(json, "items") then json[items]
    else {},

  ExtractNextToken = (json as any) as nullable text =>
    if Value.Is(json, type record) and Record.HasFields(json, "next_page") then json[next_page]
    else if Value.Is(json, type record) and Record.HasFields(json, "next") then json[next]
    else null,

  ListToTable = (lst as list) as table =>
    let
      tbl =
        try Table.FromRecords(lst, null, MissingField.UseNull)
        otherwise try Table.FromList(lst, Splitter.SplitByNothing(), {"Record"})
        otherwise #table({}, {})
    in
      tbl,

  // Build query per page — single Record.Combine, filter text pre-computed above
  BuildQuery =
    (nextToken as nullable text, applyFilters as logical, days as nullable number, extra as nullable record) as record =>
    let
      parts = List.RemoveNulls({
        if nextToken <> null then [ next_page = nextToken ] else null,
        if days <> null then [ days = Text.From(days) ] else null,
        if applyFilters and FiltersText <> null then [ filters = FiltersText ] else null,
        extra
      }),
      final = if List.IsEmpty(parts) then [] else Record.Combine(parts)
    in
      final,

  // Core token-paged fetcher
  TokenPagedFetch =
    (endpoint as text, optional applyFilters as nullable logical, optional days as nullable number, optional extraQuery as nullable record) as table =>
    let
      EndptLower = Text.Lower(Text.Trim(endpoint)),
      Relative   = "enterprise/v1/" & EndptLower,
      UseFilt    = if applyFilters = null then true else applyFilters,

      GetOne = (tok as nullable text) as record =>
        let
          q       = BuildQuery(tok, UseFilt, days, extraQuery),
          json    = FetchWithRetry(Relative, q),
          records = ExtractList(json),
          nextTok = ExtractNextToken(json)
        in
          [records = records, next = nextTok],

      Pages =
        List.Generate(
          () => [res = GetOne(null), seen = {}],
          each List.Count([res][records]) > 0,
          each
            let
              nxt = [res][next] ?? ""
            in
              if nxt = "" or List.Contains([seen], nxt) then
                [res = [records = {}, next = null], seen = [seen]]
              else
                [res = GetOne(nxt), seen = List.Combine({[seen], {nxt}})],
          each [res][records]
        ),

      Flat = List.Combine(Pages),
      Tbl  = ListToTable(Flat)
    in
      Tbl,

  CoLabEndpoint =
    (endpoint as text, optional applyFilters as nullable logical, optional days as nullable number, optional extraQuery as nullable record) as table =>
      TokenPagedFetch(endpoint, applyFilters, days, extraQuery)
in
  CoLabEndpoint
